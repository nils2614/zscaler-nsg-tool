package main

import (
	"fmt"
	"github.com/pelletier/go-toml/v2"
	"os"
	"strconv"
)

// Struct to hold information from Zscaler API and config file
type (
	zpaApi struct {
		CloudName string `json:"Cloud Name"`
		Content   []struct {
			IPProtocol string   `json:"IP Protocol"`
			Port       int      `json:"Port"`
			Source     string   `json:"Source"`
			Domains    string   `json:"Domains"`
			IPs        []string `json:"IPs"`
			DateAdded  string   `json:"Date Added"`
		} `json:"content"`
	}

	hubApi struct {
		CloudName   string   `json:"cloudName"`
		Type        string   `json:"type"`
		HubPrefixes []string `json:"hubPrefixes"`
	}

	myConfig struct {
		Main      cfgMain
		Zscaler   cfgZscaler
		Resources cfgResources
	}

	cfgMain struct {
		Priority    int
		OutputNsg   string
		OutputVars  string
		OutputRules string
	}

	cfgZscaler struct {
		Hub    cfgZscalerHub
		Zpa    cfgZscalerZpa
		Custom cfgZscalerCustom
	}

	cfgZscalerHub struct {
		Enabled bool
		Url     string
	}

	cfgZscalerZpa struct {
		Enabled bool
		Url     string
	}

	cfgZscalerCustom struct {
		Enabled bool
		Ips     []string
	}

	cfgResources struct {
		RgNameTf  string
		NsgNameTf string
		NsgNameAz string
	}
)

func main() {
	fmt.Println("Starting..")

	var cfg myConfig
	configFile, err := os.ReadFile("config.toml")
	if err != nil {
		fmt.Println("Error loading config file:", err.Error())
	} else {
		err = toml.Unmarshal(configFile, &cfg)
		if err != nil {
			fmt.Println("Error loading config file:", err.Error())
		}
	}

	// Initialise slices to hold the output text
	var outputNsgText []string   // holds content for file cfg.Main.OutputNsg
	var outputVarsText []string  // holds content for file cfg.Main.OutputVars
	var outputRulesText []string // holds content for file cfg.Main.OutputRules

	// Generate output for cfg.Main.OutputNsg and cfg.Main.OutputVars
	outputNsgText = generateNsgDefinition(cfg.Resources.RgNameTf, cfg.Resources.NsgNameTf, cfg.Resources.NsgNameAz)
	outputVarsText = generateVarDefinition(cfg.Resources.NsgNameTf)

	// Generate output for cfg.Main.OutputRules
	fmt.Println("First priority: " + strconv.Itoa(cfg.Main.Priority))

	// Write to output files
	writeToFile(outputNsgText, cfg.Main.OutputNsg)
	writeToFile(outputVarsText, cfg.Main.OutputVars)
	writeToFile(outputRulesText, cfg.Main.OutputRules)

	fmt.Println("Terraform code successfully generated!")
}

func generateNsgDefinition(rgNameTf string, nsgNameTf string, nsgNameAz string) []string {
	var NsgDefinition []string // empty slice to store Terraform code line by line

	// Terraform NSG definition code
	NsgDefinition = append(NsgDefinition, "# Terraform code generated by zscaler-nsg-tool")
	NsgDefinition = append(NsgDefinition, "resource \"azurerm_network_security_group\" \""+nsgNameTf+"\" {")
	NsgDefinition = append(NsgDefinition, "  name                = \""+nsgNameAz+"\"")
	NsgDefinition = append(NsgDefinition, "  location            = data.azurerm_resource_group."+rgNameTf+".location")
	NsgDefinition = append(NsgDefinition, "  resource_group_name = data.azurerm_resource_group."+rgNameTf+".name")
	NsgDefinition = append(NsgDefinition, "")

	NsgDefinition = append(NsgDefinition, "  dynamic \"security_rule\" {")
	NsgDefinition = append(NsgDefinition, "    for_each = var.restrict_zscaler")
	NsgDefinition = append(NsgDefinition, "    content {")
	NsgDefinition = append(NsgDefinition, "      name                       = security_rule.value.name")
	NsgDefinition = append(NsgDefinition, "      priority                   = security_rule.value.priority")
	NsgDefinition = append(NsgDefinition, "      direction                  = security_rule.value.direction")
	NsgDefinition = append(NsgDefinition, "      access                     = security_rule.value.access")
	NsgDefinition = append(NsgDefinition, "      protocol                   = security_rule.value.protocol")
	NsgDefinition = append(NsgDefinition, "      source_port_range          = security_rule.value.source_port_range")
	NsgDefinition = append(NsgDefinition, "      destination_port_range     = security_rule.value.destination_port_range")
	NsgDefinition = append(NsgDefinition, "      source_address_prefix      = security_rule.value.source_address_prefix")
	NsgDefinition = append(NsgDefinition, "      destination_address_prefix = security_rule.value.destination_address_prefix")
	NsgDefinition = append(NsgDefinition, "    }")
	NsgDefinition = append(NsgDefinition, "  }")

	NsgDefinition = append(NsgDefinition, "")
	NsgDefinition = append(NsgDefinition, "}")

	return NsgDefinition
}

func generateVarDefinition(nsgNameTf string) []string {
	var VarDefinition []string // empty slice to store Terraform code line by line

	// Terraform variable definition code
	VarDefinition = append(VarDefinition, "# Terraform code generated by zscaler-nsg-tool")
	VarDefinition = append(VarDefinition, "variable \""+nsgNameTf+"\" {")
	VarDefinition = append(VarDefinition, "  type = list(object({")

	VarDefinition = append(VarDefinition, "    name                       = string")
	VarDefinition = append(VarDefinition, "    priority                   = number")
	VarDefinition = append(VarDefinition, "    direction                  = string")
	VarDefinition = append(VarDefinition, "    access                     = string")
	VarDefinition = append(VarDefinition, "    protocol                   = string")
	VarDefinition = append(VarDefinition, "    source_port_range          = string")
	VarDefinition = append(VarDefinition, "    destination_port_range     = string")
	VarDefinition = append(VarDefinition, "    source_address_prefix      = string")
	VarDefinition = append(VarDefinition, "    destination_address_prefix = string")
	VarDefinition = append(VarDefinition, "  }))")
	VarDefinition = append(VarDefinition, "  description = \"Security rules for the "+nsgNameTf+" NSG\"")
	VarDefinition = append(VarDefinition, "}")

	return VarDefinition
}

func writeToFile(lines []string, filename string) {
	file, err := os.Create(filename)
	if err != nil {
		fmt.Println("Error creating file on disk")
	}
	defer func(file *os.File) {
		err := file.Close()
		if err != nil {
			fmt.Println("Error closing file")
		}
	}(file)

	for _, line := range lines {
		_, err := file.WriteString(line + "\n")
		if err != nil {
			fmt.Println("Error writing to file on disk")
		}
	}
}
